
import typing

from abaqus_model import part
from abaqus_model import base
from abaqus_model import step


class AbaqusModel:
    name: str
    parts: typing.Dict[str, part.Part]
    steps: typing.List[step.StepBase]
    # TODO - loads in steps


    def __init__(self, name: str):
        self.name = name
        self.parts = dict()
        self.steps = list()

    def add_part(self, one_part: part.Part):
        self.parts[one_part.name] = one_part

    def add_step(self, one_step: step.StepBase):
        self.steps.append(one_step)

    def produce_inp_lines(self) -> typing.Iterable[str]:
        yield from self._produce_inp_lines_header()
        yield from base.inp_heading("PARTS")
        for part in self.parts.values():
            yield from part.produce_inp_lines()

        yield from self._produce_inp_lines_assembly()
        yield from self._produce_inp_lines_material()

    def _produce_inp_lines_header(self) -> typing.Iterable[str]:
        yield "*Heading"
        yield f"** Job name: Job-1 Model name: {self.name}"
        yield "** Generated by: Abaqus/CAE 2016"
        yield "*Preprint, echo=NO, model=NO, history=NO, contact=NO"

    def _produce_inp_lines_assembly(self) -> typing.Iterable[str]:
        yield from base.inp_heading("ASSEMBLY")
        yield f"*Assembly, name=Assembly"
        yield "**"
        for part_name in self.parts.keys():
            yield f"*Instance, name={part_name}-1, part={part_name}"

        # Need an assembly-level node set to apply the constraints.
        # As per ANALYSIS_1.pdf, 2.1.1â€“9, we can reference the node sets in the parts.
        unique_name = base.deterministic_key(self, self.name)

        yield f"*Nset, nset={unique_name}"
        part_set_names = [f"{part.name}.{part.everything_set_name()}" for part in self.parts.values()]
        yield ", ".join(part_set_names)

        # For now, hard code a cylindrical axis system along the Y axis
        yield f"*Transform, nset={unique_name}, type=C"
        yield " 0.,         10.,           0.,           0.,         15.,           0."

        for one_part in self.parts.values():
            yield from one_part.produce_equation_inp_line()

        yield "*End Assembly"


    def _produce_inp_lines_material(self) -> typing.Iterable[str]:
        yield from base.inp_heading("MATERIALS")
        for one_part in self.parts.values():
            yield from one_part.common_material.produce_inp_lines()


    def _produce_inp_lines_steps(self) ->  typing.Iterable[str]:
        yield "** -----------------------------"
        for one_step in self.steps:
            yield from base.inp_heading(f"STEP: {one_step.name}")
            yield from one_step.produce_inp_lines()






def make_test_model() -> AbaqusModel:

    one_part = part.test_make_part()

    model = AbaqusModel("Test Model")
    model.add_part(one_part)

    return model

if __name__ == "__main__":
    model = make_test_model()
    for l in model.produce_inp_lines():
        print(l)











