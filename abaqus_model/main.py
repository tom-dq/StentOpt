
import typing

from abaqus_model import part
from abaqus_model import base
from abaqus_model import step
from abaqus_model import load

# Todo
#   - Surfaces for (i.e., inner surface, outer surface)...


class AbaqusModel:
    name: str
    parts: typing.Dict[str, part.Part]
    steps: typing.List[step.StepBase]
    step_loads: typing.Set[typing.Tuple[step.StepBase, load.LoadBase]]

    _main_sep_line: str = "** -----------------------------"

    def __init__(self, name: str):
        self.name = name
        self.parts = dict()
        self.steps = list()
        self.step_loads = set()

    def add_part(self, one_part: part.Part):
        self.parts[one_part.name] = one_part

    def add_step(self, one_step: step.StepBase):
        self.steps.append(one_step)

    def add_load_starting_from(self, starting_step: step.StepBase, one_load: load.LoadBase):
        """Add a load at a step, and for all the following steps."""
        on_this_one = False
        for one_step in self.steps:
            on_this_one = on_this_one or one_step == starting_step
            if on_this_one:
                self.step_loads.add( (one_step, one_load))

        if not on_this_one:
            raise ValueError(f"Did not find {starting_step} in AbaqusModel.steps")

    def add_load_specific_steps(self, active_steps: typing.Iterable[step.StepBase], one_load: load.LoadBase):
        """Add a load but only at particular steps (so you can turn it off after a while)."""
        for one_step in active_steps:
            self.step_loads.add((one_step, one_load))

            if one_step not in self.steps:
                raise ValueError(f"Did not find {one_step} in AbaqusModel.steps")


    def produce_inp_lines(self) -> typing.Iterable[str]:
        yield from self._produce_inp_lines_header()
        yield from base.inp_heading("PARTS")
        for part in self.parts.values():
            yield from part.produce_inp_lines()

        yield from self._produce_inp_lines_assembly()
        yield from self._produce_inp_lines_material()
        yield from self._produce_inp_lines_steps()


    def _produce_inp_lines_header(self) -> typing.Iterable[str]:
        yield "*Heading"
        yield f"** Job name: Job-1 Model name: {self.name}"
        yield "** Generated by: Abaqus/CAE 2016"
        yield "*Preprint, echo=NO, model=NO, history=NO, contact=NO"

    def _produce_inp_lines_assembly(self) -> typing.Iterable[str]:
        yield from base.inp_heading("ASSEMBLY")
        yield f"*Assembly, name=Assembly"
        yield "**"
        instance_names = []
        for part_name, one_part in self.parts.items():
            instance_names.append(one_part.name_instance)
            yield f"*Instance, name={one_part.name_instance}, part={part_name}"
            yield "*End Instance"

        yield "**"

        # Need an assembly-level node set to apply the constraints.
        # As per ANALYSIS_1.pdf, 2.1.1â€“9, we can reference the node sets in the parts.
        unique_name = base.deterministic_key(self, self.name)

        if len(instance_names) != 1:
            raise ValueError("Time to deal with this!")

        yield f"*Nset, nset={unique_name}, instance={instance_names[0]}"
        part_set_names = [part.get_everything_set().get_name(base.SetContext.part) for part in self.parts.values()]
        yield ", ".join(part_set_names)

        # For now, hard code a cylindrical axis system along the Y axis
        yield f"*Transform, nset={unique_name}, type=C"
        yield " 0.,         10.,           0.,           0.,         15.,           0."

        for one_part in self.parts.values():
            yield from one_part.produce_equation_inp_line()

        yield "*End Assembly"


    def _produce_inp_lines_material(self) -> typing.Iterable[str]:
        yield from base.inp_heading("MATERIALS")
        for one_part in self.parts.values():
            yield from one_part.common_material.produce_inp_lines()

    def _get_sorted_loads(self):
        all_loads = set(one_load for _, one_load in self.step_loads)

        def sort_key(one_load: load.LoadBase):
            return one_load.sortable()

        return sorted(all_loads, key=sort_key)


    def _produce_inp_lines_steps(self) ->  typing.Iterable[str]:
        yield self._main_sep_line
        for one_step in self.steps:
            yield from base.inp_heading(f"STEP: {one_step.name}")
            yield from one_step.produce_inp_lines()
            yield from base.inp_heading("LOADS")

            for one_load in self._get_sorted_loads():
                all_load_events = self._step_load_actions(one_load)
                relevant_load_events = [action for a_step, action in all_load_events if a_step == one_step]
                if len(relevant_load_events) == 0:
                    pass

                elif len(relevant_load_events) == 1:
                    action = relevant_load_events.pop()
                    yield from one_load.produce_inp_lines(action)

                else:
                    raise ValueError(f"Got more than one thing to do with {one_load} and {one_step}... {relevant_load_events}")

            # Have to end the step here, after the loads have been output.

            # This outputs stuff we can read without starting CAE
            yield "*FILE OUTPUT, NUMBER INTERVAL=1"
            yield "*EL FILE"
            yield "S"

            # abaqus.bat job=job-12 interactive     >>> Run
            # abaqus.bat job=job-12 convert=select  >>> Make .fil from .sel
            # abaqus.bat ascfil job=job-12          >>> Make asciii .fin from .fil


            yield "*End Step"

    def _step_load_actions(self, one_load: load.LoadBase):
        """Get the load action for the steps (turn on, turn off, etc)."""

        active_at_last_step = False
        for idx, one_step in enumerate(self.steps):
            active_at_this_step = (one_step, one_load) in self.step_loads
            is_first_step = idx == 0

            def get_event_this_combination():
                if active_at_this_step and is_first_step:
                    return load.Action.create_first_step

                elif active_at_this_step and not active_at_last_step:
                    return load.Action.create_subsequent_step

                elif not active_at_this_step and active_at_last_step:
                    return load.Action.remove

            this_action = get_event_this_combination()
            if this_action:
                yield (one_step, this_action)

            active_at_last_step = active_at_this_step







def make_test_model() -> AbaqusModel:

    one_part = part.make_part_test()

    model = AbaqusModel("TestModel")
    model.add_part(one_part)

    all_steps = [step.make_test_step(x) for x in (1, 2, 3)]
    for one_step in all_steps:
        model.add_step(one_step)

    load_point = load.make_test_load_point("LoadSet123")
    load_dist = load.make_test_pressure("LoadPressure234")

    model.add_load_starting_from(all_steps[0], load_point)
    model.add_load_specific_steps(all_steps[0:2], load_dist)





    return model

if __name__ == "__main__":
    model = make_test_model()
    with open(r"C:\temp\aba_out.inp", "w") as fOut:
        for l in model.produce_inp_lines():
            print(l)
            fOut.write(l + "\n")


# Export








